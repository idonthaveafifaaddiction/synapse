<BsimmSurvey>
	<surveyName>BSIMM 10</surveyName>
	<functions>
		<BsimmFunction>
			<functionName>Governance</functionName>
			<practices>
				<BsimmPractice>
					<practiceName>Strategy &amp; Metrics</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SM1.1</measureId>
									<measureTitle>Publish process and evolve as necessary</measureTitle>
									<detailMessage>The process for addressing software security is published and broadcast to all stakeholders so that everyone knows the plan. Goals, roles, responsibilities, and activities are explicitly defined. Most organizations pick an existing methodology, such as the Microsoft SDL or the Synopsys Touchpoints, and then tailor it to meet their needs. The secure SDLC process must be adapted to the specifics of the development process it governs (e.g., waterfall, agile, CI/CD, DevOps, etc.) because it will evolve with both the organization and the security landscape. In many cases, the process is controlled by the SSG and published only internally; it doesn’t need to be publicly promoted outside the firm to have the desired impact. In addition to publishing the process, some firms also encode it into an application lifecycle management (ALM) tool as workflow.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SM1.2</measureId>
									<measureTitle>Create evangelism role and perform internal marketing.</measureTitle>
									<detailMessage>To build support for software security throughout the organization, someone in the SSG must play an evangelism role. This internal marketing function helps keep executives and other stakeholders up to date on the magnitude of the software security problem and the elements of its solution. An agile coach familiar with security, for example, could help teams adopt better software security practices as they transform to an agile methodology. Evangelists can increase understanding and build credibility by giving talks to internal groups (including executives), extending invitations to well-known experts, authoring white papers for internal consumption, or creating a collection of papers, books, and other resources on an internal website and promoting its use. An early example of such an evangelist was Michael Howard’s role at Microsoft just after Bill Gates’ 2002 security memo kicked off the company’s new security strategy.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SM1.3</measureId>
									<measureTitle>Educate executives.</measureTitle>
									<detailMessage>Executives are periodically shown the consequences of inadequate software security and the negative business impact it can have on the organization. They’re also shown what other organizations are doing to mature software security, including how they deal with the risks of adopting “flavor of the day” engineering methodologies with no oversight. By understanding both the problems and their proper resolutions, executives can support the SSI as a risk management necessity. In its most dangerous form, security education arrives courtesy of malicious hackers or public data exposure incidents. Preferably, the SSG will demonstrate a worst-case scenario in a controlled environment with the permission of all involved (e.g., by actually showing working exploits and their business impact). In some cases, presentation to the Board can help garner resources for an ongoing SSI. Bringing in an outside guru is often helpful when seeking to bolster executive attention. Tying education to specific development areas, such as mobile or cloud services, or particular methodologies, such as CI/CD and DevOps, can likewise help convince leadership to accept SSG recommendations when they might otherwise be ignored in favor of faster release dates or other priorities.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SM1.4</measureId>
									<measureTitle>Identify gate locations, gather necessary artifacts.</measureTitle>
									<detailMessage>The software security process includes release gates (or checkpoints, guardrails, milestones, etc.) at one or more points in the SDLC or, more likely, multiple SDLCs. The first two steps toward establishing security-specific release gates are to identify gate locations that are compatible with existing development practices and to then begin gathering the input necessary to make a go/no-go decision. Importantly, the gates might not be enforced. For example, the SSG can collect security testing results for each project prior to release then provide their informed opinion on what constitutes sufficient testing or acceptable test results without trying to stop a project from moving forward. Shorter release cycles, as seen in organizations practicing CI/CD, often require creative approaches to collecting the right evidence and rely heavily on lightweight, super- fast automation. The idea of identifying gates first and enforcing them later is extremely helpful in moving development toward software security without major pain. Socializing the gates and then turning them on once most projects already know how to succeed is a gradual approach that can motivate good behavior without requiring it.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SM2.1</measureId>
									<measureTitle>Publish data about software security internally.</measureTitle>
									<detailMessage>To facilitate improvement, the SSG publishes data internally about the state of software security within the organization. This information might come in the form of a dashboard with metrics for executives and software development management. Sometimes, these published data won’t be shared with everyone in the firm but only with relevant executives who then drive change in the organization. In other cases, open book management and data published to all stakeholders helps everyone know what’s going on, the philosophy being that sunlight is the best disinfectant. If the organization’s culture promotes internal competition between groups, this information can add a security dimension. The time compression associated with CI/CD calls for measurements that can be taken quickly and accurately, and might initially focus less on historical trends (e.g., bugs per release) and more on speed (e.g., time to fix).</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SM2.2</measureId>
									<measureTitle>Enforce gates with measurements and track exceptions.</measureTitle>
									<detailMessage>Software lifecycle security gates are enforced for every project, so to pass a gate, a project must either meet an established measure or obtain a waiver. Even recalcitrant project teams must now play along and the SSG tracks exceptions. In some cases, gates are directly associated with regulations, contractual agreements, and other obligations, with exceptions tracked as required by statutory or regulatory drivers. In other cases, gate measures yield key performance indicators that are used to govern the process. Allowing any projects to automatically pass or automatically granting waivers without due consideration defeats the purpose of enforcing a gate. Even seemingly innocuous software projects, such as a new mobile client for an existing back end or an application ported to a cloud environment from an internal data center, must successfully pass the prescribed security gates in order to progress or remain in production. Similarly, APIs, frameworks, libraries, bespoke code, microservices, container configurations, and so on are all software that must traverse the security gates. Remember, it’s possible, and often very useful, to have enforced gates both before and after the development process itself.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SM2.3</measureId>
									<measureTitle>Create or grow a satellite.</measureTitle>
									<detailMessage>Create a collection of people scattered across the organization who show an above-average level of security interest or skill—a satellite. Forming this group of advocates, sometimes referred to as champions, is a step toward creating a social network that speeds the adoption of security into software engineering. One way to build the initial group is to track the people who stand out during introductory training courses; see [T3.6 Identify new satellite members through training]. Another way is to ask for volunteers. In a more top-down approach, initial satellite membership is assigned to ensure complete coverage of all development/product groups, but ongoing membership is based on actual performance. A strong satellite is a good sign of a mature SSI. In new or fast-moving technology areas, satellite members can help combine software security skills with domain knowledge that might be underrepresented in the SSG. Agile coaches and DevOps engineers make particularly useful satellite members, especially for detecting and removing process friction.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SM2.6</measureId>
									<measureTitle>Require security sign-off.</measureTitle>
									<detailMessage>The organization has an initiative-wide process for accepting security risk and documenting accountability, with a risk acceptor signing off on the state of all software prior to release. The sign-off policy might require the head of a business unit to sign off on critical vulnerabilities that have not been mitigated or on SSDL steps that have been skipped, for example. The sign-off policy must apply both to outsourced projects, such as a boutique mobile application, and to projects that will be deployed in external environments, such as the cloud. Informal or uninformed risk acceptance alone isn’t a security sign-off because the act of accepting risk is more effective when it’s formalized (e.g., with a signature, a form submission, or something similar) and captured for future reference. Similarly, simply stating that certain projects don’t need sign-off at all won’t achieve the desired risk management results. In some cases, however, the risk acceptor can provide the sign-off on a particular set of software project acceptance criteria, which are then implemented in automation to ensure that the criteria are applied in the fastest processes; however, there must be an ongoing verification that the criteria remain accurate and the automation is actually working.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SM3.1</measureId>
									<measureTitle>Use an internal tracking application with portfolio view.</measureTitle>
									<detailMessage>The SSG uses centralized tracking automation to chart the progress of every piece of software in its purview, regardless of development methodology. The automation records the security activities scheduled, in progress, and completed, incorporating results from activities such as architecture analysis, code review, and security testing even when they happen in a tight loop. A combined inventory and risk posture view is fundamental. The SSG uses the automation to generate portfolio reports for multiple metrics and, in many cases, publishes these data, at least among executives. Depending on the culture, this can cause interesting effects via internal competition. As an initiative matures and activities become more distributed, the SSG uses the centralized reporting system to keep track of all the moving parts.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SM3.2</measureId>
									<measureTitle>Run an external marketing program.</measureTitle>
									<detailMessage>To build external awareness, the SSG helps the firm market the SSI outside the internal teams. In this way, software security can grow beyond being a risk reduction exercise and instead become a competitive advantage or market differentiator. The SSG might publish papers or books about its software security capabilities, or have a public blog. It might provide details in external conferences or trade shows. In some cases, a complete SSDL methodology can be published and promoted outside the firm, with mobile, cloud, and new technology security projects making important software security case studies. Regardless of venue, the process of sharing details externally and inviting critique is used to bring new perspectives into the firm.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SM3.3</measureId>
									<measureTitle>Identify metrics and use them to drive budgets.</measureTitle>
									<detailMessage>The SSG and its management choose the metrics that define and measure SSI progress in quantitative terms. These metrics in turn drive the initiative’s budget and resource allocations, so simple counts and out-of-context measurements won’t suffice here. One such metric could be security defect density, a reduction in which could be used to show a decreasing cost of remediation over time. Recall that, in agile methodologies, metrics are best collected early and often in a lightweight manner. The key is to tie technical results to business objectives in a clear and obvious fashion in order to justify funding. Because the concept of security is already tenuous to many business people, making an explicit tie-in can be helpful.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SM3.4</measureId>
									<measureTitle>Integrate software-defined lifecycle governance.</measureTitle>
									<detailMessage>Organizations begin replacing traditional document, presentation, and spreadsheet-based lifecycle management with software-based delivery platforms. Humans, sometimes aided by tools, no longer drive progression from each lifecycle phase to the next. Instead, organizations rely on automation to drive the management and delivery process with ALM/ ADLM software, such as Spinnaker, and humans participate asynchronously (and often optionally), like services. Automation often extends beyond the scope of CI/CD to include functional and nonfunctional aspects of delivery, including health checks, cut-over on failure, rollback to known good software, defect discovery and management, compliance verification, and a way to ensure adherence to policies and standards. Some organizations are also evolving their lifecycle management approach by integrating their compliance and defect discovery data to begin moving from a series of point-in-time go/no-go decisions (e.g., a security test at each gate) to a future state of continuous accumulation of assurance data (e.g., output from sensors embedded in development and production).</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<BsimmPractice>
					<practiceName>Compliance &amp; Policy</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>CP1.1</measureId>
									<measureTitle>Unify regulatory pressures.</measureTitle>
									<detailMessage>If the business or its customers are subject to regulatory or compliance drivers such as the Payment Card Industry security standards; GLBA, SOX, and HIPAA in the United States; or GDPR in the EU, the SSG acts as a focal point for understanding the constraints such drivers impose on software. In some cases, the SSG creates or collaborates on a unified approach that removes redundancy and conflicts from overlapping compliance requirements. A formal approach will map applicable portions of regulations to control statements explaining how the organization complies. As an alternative, existing business processes run by legal or other risk and compliance groups outside the SSG could also serve as the regulatory focal point. A unified set of software security guidance for meeting regulatory pressures ensures that compliance work is completed as efficiently as possible. Some firms move on to influencing the regulatory environment directly by becoming involved in standards groups exploring new technologies and mandates.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CP1.2</measureId>
									<measureTitle>Identify PII obligations.</measureTitle>
									<detailMessage>The SSG plays a key role in identifying and describing PII obligations stemming from regulation and customer expectations by using this information to promote best practices related to privacy. The way software handles PII might be explicitly regulated, but even if it isn’t, privacy is a hot topic. For example, if the organization processes credit card transactions, the SSG will help in identifying the constraints that the PCI DSS places on the handling of cardholder data and then inform all stakeholders. Note that outsourcing to hosted environments (e.g., the cloud) doesn’t relax PII obligations and can even increase the difficulty of recognizing all associated obligations. Also note that firms creating software products that process PII (where the firms don’t necessarily handle it directly) can meet this need by providing privacy controls and guidance for their customers. Given evolving consumer privacy expectations, proliferation of “software is in everything” and data scraping and correlation (e.g., social media) adds yet another dimension to PII protection.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CP1.3</measureId>
									<measureTitle>Create policy.</measureTitle>
									<detailMessage>The SSG guides the rest of the organization by creating or contributing to software security policy that satisfies internal, regulatory, and customer-driven security requirements. This policy includes a unified approach for satisfying the (potentially lengthy) list of security drivers at the governance level. As a result, project teams can avoid keeping up with the details involved in complying with all applicable regulations or other mandates. Likewise, project teams won’t need to relearn customer security requirements on their own. SSG policy statements can sometimes focus on major compliance topics, such as handling PII or using cryptography. In some cases, policy will relate directly to the SSDL and its use in the firm. Because they might be new topics, codifying decisions about IoT, cloud, and mobile architectures can rekindle interest in setting policy. Similarly, it can be necessary, for example, to explain what can and can’t be automated into CI/CD and continuous deployment pipelines (see [SM3.4 Integrate software-defined lifecycle governance]). Architecture standards and coding guidelines aren’t examples of policy, but policy that prescribes and mandates the use of coding guidelines and architecture standards for certain software categories falls under the umbrella. Policy is what is permitted and denied at the initiative level; if it’s not mandatory, it’s not policy. In many cases, policy statements must be translatable into automation for use in a software-defined lifecycle, not just a process enforced by humans, but even automated policy must be mandatory.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>CP2.1</measureId>
									<measureTitle>Identify PII inventory.</measureTitle>
									<detailMessage>The organization identifies the kinds of PII processed or stored by each of its systems, along with their associated data repositories. A PII inventory can be approached in two ways: starting with each individual application by noting its PII use or starting with particular types of PII and noting the applications that touch them. System architectures have evolved such that PII will flow into cloud-based service and end-point device ecosystems, and come to rest there (e.g., content delivery networks, social networks, mobile devices, IoT devices), making it tricky to keep an accurate PII inventory. The inventory must be easily referenced in critical situations, such as making a list of databases that would require customer notification if breached or a list to use in crisis simulations.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CP2.2</measureId>
									<measureTitle>Require security sign-off for compliance-related risk.</measureTitle>
									<detailMessage>The organization has a formal compliance risk acceptance and accountability process that addresses all software development projects. In that process, the SSG acts as an advisor when the risk acceptor signs off on the software’s state prior to release. For example, the sign-off policy might require the head of the business unit to sign off on compliance issues that haven’t been mitigated or on compliance-related SSDL steps that have been skipped. Sign-off should be explicit and captured for future reference, with any exceptions tracked, even under the fastest of agile methodologies. Note that an application without security defects might still be noncompliant so a clean penetration test is not a substitute for a compliance sign- off. Even in DevOps organizations where engineers have the technical ability to release software, there is still a need for a deliberate risk acceptance step even if the criteria are embedded in automation. In cases where the risk acceptor signs off on a particular set of compliance acceptance criteria that are then implemented in automation, there must be an ongoing verification that the criteria remain accurate and the automation is actually working.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CP2.3</measureId>
									<measureTitle>Implement and track controls for compliance.</measureTitle>
									<detailMessage>The organization can demonstrate compliance with applicable requirements because its SSDL is aligned with the control statements developed by the SSG (see [CP1.1 Unify regulatory pressures]). The SSG tracks SDLC controls, navigates problem areas, and ensures auditors and regulators are satisfied. If the organization’s SDLC is predictable and reliable, the SSG might be able to remain in the background because following the SSDL generates the desired compliance evidence. Increasingly, the DevOps approach of embedding compliance controls in process shows up within software-defined infrastructure and networks rather than in process and manual intervention. A firm doing this properly can explicitly associate satisfying its compliance concerns with following its SSDL.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CP2.4</measureId>
									<measureTitle>Include software security SLAs in all vendor contracts.</measureTitle>
									<detailMessage>Vendor contracts include an SLA to ensure that a vendor won’t jeopardize the organization’s compliance story or SSI. Each new or renewed contract contains provisions requiring the vendor to address software security and deliver a product or service compatible with the organization’s security policy (see [SR2.5 Create SLA boilerplate]). In some cases, open source licensing concerns initiate the vendor management process, which can open the door for additional software security language in the SLA. Traditional IT security requirements and a simple agreement to allow penetration testing aren’t sufficient here.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CP2.5</measureId>
									<measureTitle>Ensure executive awareness of compliance and privacy obligations.</measureTitle>
									<detailMessage>To gain executive buy-in around compliance and privacy activities, the SSG provides executives with plain-language explanations of the organization’s compliance and privacy obligations, along with the potential consequences of failing to meet those obligations. For some organizations, explaining the direct cost and likely fallout from a compliance failure or data breach is be an effective way to broach the subject. For others, having an outside expert address the Board works because some executives value an outside perspective more than an internal one. A sure sign of proper executive buy-in is adequate allocation of resources to meet those obligations. While useful for bootstrapping efforts, be aware that the sense of urgency typically following a breach will not last.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>CP3.1</measureId>
									<measureTitle>Create a regulator compliance story.</measureTitle>
									<detailMessage>The SSG has the information regulators want, so a combination of written policy, controls documentation, and artifacts gathered through the SSDL gives the SSG the ability to demonstrate the organization’s compliance story without a fire drill for every audit or a piece of paper for every sprint. Often, regulators, auditors, and senior management will be satisfied with the same kinds of reports that can be generated directly from various tools. In some cases, the organization will require additional information from vendors about how the vendor’s controls support organizational compliance needs (e.g., cloud providers, especially in a multi-cloud deployment). It will often be necessary to normalize information that comes from disparate sources. While they are often the biggest, governments aren’t the only regulators of behavior.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CP3.2</measureId>
									<measureTitle>Impose policy on vendors.</measureTitle>
									<detailMessage>Vendors are required to adhere to the same policies used internally and must submit evidence that their software security practices pass muster. For a given organization, vendors might comprise cloud providers, middleware providers, virtualization providers, container and orchestration providers, bespoke software creators, contractors, and many more, and each might be held to different policy requirements. Evidence of their compliance could include results from code reviews or penetration tests, or from tests built directly into automation or infrastructure. Vendors might attest to the fact that they perform certain SSDL processes. In some cases, a BSIMM score or a BSIMMsc score can help ensure that vendors are complying with the firm’s software security policies.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CP3.3</measureId>
									<measureTitle>Drive feedback from SSDL data back to policy.</measureTitle>
									<detailMessage>Information from the software lifecycle is routinely fed back into the policy creation process to help find defects earlier or to prevent them from occurring in the first place. In doing so, blind spots can be eliminated by mapping them to trends in SSDL failures. The regular appearance of inadequate architecture analysis, recurring vulnerabilities, ignored security gates, or the wrong firm choice for carrying out a penetration test can expose policy weakness. In some cases, lifecycle data might indicate that policies impose too much bureaucracy, for example, by introducing friction that prevents engineering from meeting the expected delivery cadence. Rapid technology evolution might also create policy gaps that must be addressed. Over time, policies become more practical and easier to carry out (see [SM1.1 Publish process and evolve as necessary]). Ultimately, policies are refined with SSDL data to enhance and improve a firm’s effectiveness.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<BsimmPractice>
					<practiceName>Training</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>T1.1</measureId>
									<measureTitle>Conduct awareness training.</measureTitle>
									<detailMessage>To promote a culture of software security throughout the organization, the SSG conducts awareness training. As examples, the training might be delivered via SSG members, an outside firm, the internal training organization, or e-learning. Course content doesn’t necessarily have to be tailored for a specific audience. For example, all developers, QA engineers, and project managers could attend the same “Introduction to Software Security” course, but this activity should be enhanced with a tailored approach that addresses the firm’s culture explicitly. Generic introductory courses that cover basic IT or high-level software security concepts don’t generate satisfactory results. Likewise, awareness training aimed only at developers and not at other roles in the organization is insufficient.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>T1.5</measureId>
									<measureTitle>Deliver role-specific advanced curriculum.</measureTitle>
									<detailMessage>Software security training goes beyond building awareness by enabling trainees to incorporate security practices into their work. This training is tailored to cover the tools, technology stacks, development methodologies, and bugs that are most relevant to the trainees. For example, an organization could offer four tracks for its engineers: one for architects, one for Java developers, one for mobile developers, and a fourth for testers. Tool-specific training is also commonly observed in such a curriculum. Note that training is important for many different roles within an organization, including QA, product management, executives, and others.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>T1.7</measureId>
									<measureTitle>Deliver on-demand individual training.</measureTitle>
									<detailMessage>The organization lowers the burden on trainees and reduces the cost of delivering training by offering on-demand training for individuals across roles. The most obvious choice, e-learning, can be kept up to date through a subscription model, but an online curriculum must be engaging and relevant to the trainees in various roles to achieve its intended purpose. Training that isn’t used won’t create any change, and hot topics like new IoT and cloud architectures and new delivery styles such as gamification will attract more interest than boring policy discussions. For developers, it’s possible to provide training directly through the IDE right when it’s needed, but in some cases, building a new skill (such as code review or threat modeling) might be better suited for instructor-led training, which can also be provided on demand.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>T2.5</measureId>
									<measureTitle>Enhance satellite through training and events.</measureTitle>
									<detailMessage>The SSG strengthens the satellite network by inviting guest speakers or holding special events about advanced topics (e.g., the latest software security techniques for DevOps or AWS cloud development). Offering attendees coffee and snacks doesn’t hurt. This effort is about providing the satellite customized training so that it can fulfill its specific responsibilities, not about inviting the satellite members to brown bags or signing them up for the standard computer-based training. In addition, a standing conference call with voluntary attendance won’t get the desired results, which are as much about building camaraderie as they are about sharing knowledge and organizational efficiency. Face-to-face meetings are by far the most effective, even if they happen only once or twice a year and some participants must attend over videoconferencing.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>T2.6</measureId>
									<measureTitle>Include security resources in onboarding.</measureTitle>
									<detailMessage>The process for bringing new hires into an engineering organization requires that they complete a training module about software security. The generic new hire process usually covers topics like picking a good password and making sure that people don’t follow you into the building, but this orientation period can be enhanced to cover topics such as secure coding, the SSDL, and internal security resources. The objective is to ensure that new hires contribute to the security culture. Turnover in engineering organizations is generally high, and although a generic onboarding module is useful, it doesn’t take the place of a timely and more complete introductory software security course.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>T2.8</measureId>
									<measureTitle>Create and use material specific to company history.</measureTitle>
									<detailMessage>To make a strong and lasting change in behavior, training includes material specific to the company’s history. When participants can see themselves in a problem, they’re more likely to understand how the material is relevant to their work as well as when and how to apply what they’ve learned. One way to do this is to use noteworthy attacks on the company’s software as examples in the training curriculum. This training shouldn’t cover platforms not used by developers (Windows developers probably won’t care about old Unix problems) or examples of problems relevant only to languages no longer in common use (Java developers probably don’t need to understand buffer overflows in C). Stories from company history can help steer training in the right direction, but only if those stories are still relevant and not overly censored. Both successful and unsuccessful attacks can make good teachable moments.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>T3.1</measureId>
									<measureTitle>Reward progression through curriculum (certification or HR).</measureTitle>
									<detailMessage>Knowledge is its own reward, but progression through the security curriculum brings other benefits, too, such as career advancement. The reward system can be formal and lead to a certification or an official mark in the human resources system, or it can be less formal and include motivators such as documented praise at annual review time. Involving a corporate training department and/or HR team can make security’s impact on career progression more obvious, but the SSG should continue to monitor security knowledge in the firm and not cede complete control or oversight. Coffee mugs and t-shirts can build morale, but it might take the possibility of real career progression to change behavior.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>T3.2</measureId>
									<measureTitle>Provide training for vendors or outsourced workers.</measureTitle>
									<detailMessage>Vendors and outsourced workers receive the same level of software security training given to employees. Spending time and effort helping suppliers get security right at the outset is much easier than trying to determine what went wrong later on, especially if the development team has moved on to other projects. Training individual contractors is much more natural than training entire outsource firms and is a reasonable place to start. It’s important that everyone who works on the firm’s software has an appropriate level of training, regardless of their employment status.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>T3.3</measureId>
									<measureTitle>Host software security events.</measureTitle>
									<detailMessage>The organization highlights its security culture as a differentiator by hosting security events featuring external speakers and content. Good examples of this are Microsoft’s BlueHat and QUALCOMM’s Mobile Security Summit, given their featuring of external presenters and their focus on helping development create better code. Employees benefit from hearing outside perspectives, especially those related to fast-moving technology areas, and the organization as a whole benefits from putting its security credentials on display (see [SM3.2 Run an external marketing program]). Events open only to small, select groups won’t result in the desired culture change across the organization.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>T3.4</measureId>
									<measureTitle>Require an annual refresher.</measureTitle>
									<detailMessage>Everyone involved in the SSDL is required to take an annual software security refresher course. This course keeps the staff up to date on security and ensures that the organization doesn’t lose focus due to turnover, evolving methodologies, or changing deployment models. The SSG might take half a day to give an update on the security landscape and explain changes to policies and standards. A refresher can also be rolled out as part of a firm-wide security day or in concert with an internal security conference, but it’s useful only if it’s fresh.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>T3.5</measureId>
									<measureTitle>Establish SSG office hours.</measureTitle>
									<detailMessage>The SSG offers help to anyone during an advertised lab period or regularly scheduled office hours. By acting as an informal resource for people who want to solve security problems, the SSG leverages teachable moments and emphasizes the carrot over the stick approach to security best practices. Office hours might be held one afternoon per week in the office of a senior SSG member, but roving office hours are also a possibility, with visits to particular product or application groups by request, perhaps prioritizing visits by key functionality being developed and its security implications.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>T3.6</measureId>
									<measureTitle>Identify new satellite members through training.</measureTitle>
									<detailMessage>Recruit future satellite members (e.g., champions) by noting people who stand out during training courses, office hours, capture-the-flag exercises, hack-a-thons, and other opportunities to show skill and enthusiasm, and encouraging them to join the satellite. The satellite often begins as an assigned collection of people scattered across the organization who show an above-average level of security interest or advanced knowledge of new technology stacks and development methodologies (see [SM2.3 Create or grow a satellite]). Identifying future members proactively is a step toward creating a social network that speeds the adoption of security into software development and operations. A group of enthusiastic and skilled volunteers will be easier to lead than a group that is drafted.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<!--Additional BsimmPractice Objects-->
			</practices>
		</BsimmFunction>
		<BsimmFunction>
			<functionName>Intelligence</functionName>
			<practices>
				<BsimmPractice>
					<practiceName>Attack Models</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>AM1.2</measureId>
									<measureTitle>Create a data classification scheme and inventory.</measureTitle>
									<detailMessage>Security stakeholders in an organization agree on a data classification scheme and use it to inventory software according to the kinds of data the software handles, regardless of whether the software is on or off premise. This allows applications to be prioritized by their data classification. Many classification schemes are possible—one approach is to focus on PII, for example. Depending on the scheme and the software involved, it could be easiest to first classify data repositories (see [CP2.1 Identify PII inventory]) and then derive classifications for applications according to the repositories they use. Other approaches to the problem include data classification according to protection of intellectual property, impact of disclosure, exposure to attack, relevance to GDPR, or geographic boundaries.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AM1.3</measureId>
									<measureTitle>Identify potential attackers.</measureTitle>
									<detailMessage>The SSG identifies potential attackers in order to understand their motivations and abilities. The outcome of this exercise could be a set of attacker profiles that includes generic sketches for categories of attackers and more detailed descriptions for noteworthy individuals. In some cases, a third-party vendor might be contracted to provide this information. Specific and contextual attacker information is almost always more useful than generic information copied from someone else’s list. Moreover, a list that simply divides the world into insiders and outsiders won’t drive useful results. Identification of attackers should account for the organization’s evolving software supply chain and attack surface.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AM1.5</measureId>
									<measureTitle>Gather and use attack intelligence.</measureTitle>
									<detailMessage>The SSG stays ahead of the curve by learning about new types of attacks and vulnerabilities. In particular, by attending technical conferences and monitoring attacker forums, then correlating that information with what’s happening in the organization (perhaps by reviewing operational logs and telemetry), the SSG can identify potential problems and collaborate with experts to learn more about emerging vulnerability exploitation. In many cases, a subscription to a commercial service can provide a reasonable way of gathering basic attack intelligence. Regardless of its origin, attack information must be made actionable and useful for developers, testers, and DevOps engineers.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>AM2.1</measureId>
									<measureTitle>Build attack patterns and abuse cases tied to potential attackers.</measureTitle>
									<detailMessage>The SSG prepares for security testing and architecture analysis by building attack patterns and abuse cases tied to potential attackers (see [AM1.3 Identify potential attackers]). However, these resources don’t have to be built from scratch for every application in order to be useful; rather, standard sets might exist for applications with similar profiles, and the SSG can add to the pile based on its own attack stories. For example, a story about an attack against a poorly designed cloud application could lead to a cloud security attack pattern that drives a new type of testing. If a firm tracks the fraud and monetary costs associated with particular attacks, this information can in turn be used to prioritize the process of building attack patterns and abuse cases. Evolving software architectures (e.g., microservices, serverless) might require organizations to evolve their attack pattern and abuse case creation approach and content.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AM2.2</measureId>
									<measureTitle>Create technology-specific attack patterns.</measureTitle>
									<detailMessage>The SSG creates technology-specific attack patterns to capture its knowledge about attacks that target specific technologies. For example, if the organization’s cloud software relies on a cloud vendor’s security apparatus (e.g., cryptography), the SSG can catalogue the quirks of the crypto package and how it might be exploited. Attack patterns directly related to the security frontier (e.g., IoT) can be useful here as well. It’s often easiest to start with existing generalized attack patterns to create the needed technology-specific attack patterns, but simply adding, for example, “for mobile applications” at the end won’t suffice.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AM2.5</measureId>
									<measureTitle>Build and maintain a top N possible attacks list.</measureTitle>
									<detailMessage>The SSG periodically digests the ever-growing list of attack types and focuses the organization on prevention efforts for a prioritized short list—the top N—and uses it to drive change. This initial list can combine input from multiple sources, both inside and outside the organization. Some organizations prioritize their list according to perception of potential business loss while others might prioritize according to successful attacks against their software. The top N list doesn’t need to be updated with great frequency, and attacks can be coarsely sorted. For example, the SSG might brainstorm twice a year to create lists of attacks the organization should be prepared to counter “now,” “soon,” and “someday.”</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AM2.6</measureId>
									<measureTitle>Collect and publish attack stories.</measureTitle>
									<detailMessage>To maximize the benefit from lessons that don’t always come cheap, the SSG collects and publishes stories about attacks against the organization. Both successful and unsuccessful attacks can be noteworthy, and discussing historical information about software attacks has the added effect of grounding software security in a firm’s reality. This is particularly useful in training classes, to help counter a generic approach that might be overly focused on other people’s top 10 lists or outdated platform attacks (see [T1.6 Create and use material specific to company history]). Hiding information about attacks from people building new systems fails to garner any positive benefits from a negative happenstance.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AM2.7</measureId>
									<measureTitle>Build an internal forum to discuss attacks.</measureTitle>
									<detailMessage>The organization has an internal forum where the SSG, the satellite, and others discuss attacks and attack methods. The discussion serves to communicate the attacker perspective to everyone. The SSG can also maintain an internal mailing list that encourages subscribers to discuss the latest information on publicly known incidents. Dissection of attacks and exploits that are relevant to a firm are particularly helpful when they spur discussion of development, infrastructure, and other mitigations. Simply republishing items from public mailing lists doesn’t achieve the same benefits as active discussion, nor does a closed discussion hidden from those actually creating code. Everyone should feel free to ask questions and learn about vulnerabilities and exploits (see [SR1.2 Create a security portal]).</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>AM3.1</measureId>
									<measureTitle>Have a science team that develops new attack methods.</measureTitle>
									<detailMessage>The SSG has a science team that works to identify and defang new classes of attacks before real attackers even know that they exist. Because the security implications of new technologies haven’t been fully explored in the wild, doing it in house is sometimes the best way forward. This isn’t a penetration testing team finding new instances of known types of weaknesses—it’s a research group that innovates new types of attacks. A science team could even include well-known security researchers who publish their findings at conferences like DEF CON.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AM3.2</measureId>
									<measureTitle>Create and use automation to mimic attackers.</measureTitle>
									<detailMessage>The SSG arms testers with automation to mimic what attackers are going to do. For example, a new attack method identified by the science team could require a new tool, so the SSG could package the tool and distribute it to testers. The idea here is to push attack capability past what typical commercial tools and offerings encompass, and then make that knowledge and technology easy for others to use. Tailoring these new tools to a firm’s particular technology stacks and potential attackers increases the overall benefit. When technology stacks and coding languages evolve faster than vendors can innovate, creating tools and automation in house might be the best way forward. In the DevOps world, these tools might be created by engineering and embedded directly into toolchains and automation (e.g., Chaos Monkey).</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AM3.3</measureId>
									<measureTitle>Monitor automated asset creation.</measureTitle>
									<detailMessage>The SSG implements technology controls that provide a continuously updated view of the various network, machine, software, and related infrastructure assets being instantiated by engineering teams as part of their ALM processes. The SSG works with the engineering teams to understand the custom automation and cloud provider dashboards engineering uses to quickly stand-up servers, databases, networks, and entire clouds for software deployments. Monitoring the changes in application design (e.g., moving a monolithic application to microservices) is also part of this effort. This monitoring requires a specialized effort; normal system, network, and application logging and analysis won’t suffice. Success might require a multi-pronged approach, including consuming orchestration and virtualization metadata, querying cloud service provider APIs, and outside-in web crawling and scraping. As processes improve, the data will be helpful for threat modeling efforts (see [AA1.1 Perform security feature review]).</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<BsimmPractice>
					<practiceName>Security Features &amp; Design</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SFD1.1</measureId>
									<measureTitle>Build and publish security features.</measureTitle>
									<detailMessage>Rather than having each project team implement its own security features (e.g., authentication, role management, key management, audit/log, cryptography, protocols), the SSG provides proactive guidance by acting as a clearinghouse of security features for development groups to use. These features might be discovered during code review, created by the SSG or a specialized development team, or be part of a library provided by a vendor, such as a cloud service provider. Generic security features often have to be tailored for specific platforms. A mobile crypto feature will likely need at least two versions to cover Android and iOS, while managing identity in the cloud might require versions specific to AWS, Google, and Azure. Project teams benefit from implementations that come preapproved by the SSG, and the SSG benefits by not having to repeatedly track down the kinds of subtle errors that often creep into security features.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SFD1.2</measureId>
									<measureTitle>Engage SSG with architecture.</measureTitle>
									<detailMessage>Security is a regular topic in the organization’s software architecture discussions, with the architecture team taking responsibility for security in the same way that it takes responsibility for performance, availability, and scalability. One way to keep security from falling out of these discussions is to have an SSG member participate in architecture discussions. In other cases, enterprise architecture teams can help the SSG create secure designs that integrate properly into corporate design standards. Proactive engagement by the SSG is key to success here. Moving a well-known system to the cloud means reengaging the SSG, for example. It’s never safe for one team to assume another team has addressed security requirements.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SFD2.1</measureId>
									<measureTitle>Build secure-by-design middleware frameworks and common libraries.</measureTitle>
									<detailMessage>The SSG takes a proactive role in software design by building or providing pointers to secure-by-design middleware frameworks or common libraries. In addition to teaching by example, this middleware aids architecture analysis and code review because the building blocks make it easier to spot errors. For example, the SSG can modify a popular web framework, such as Spring, to make it easy to meet input validation requirements. Eventually, the SSG can tailor code review rules specifically for the components it offers (see [CR3.1 Use automated tools with tailored rules]). When adopting a middleware framework (or any other widely used software), the SSG must carefully vet the software for security before publication. Encouraging adoption and use of insecure middleware doesn’t help the overall software security goal. Generic open source software security frameworks and libraries (e.g., Spring Security, NaCl), should not be considered secure by design. Attempting to bolt security on at the end by calling a library is always an unsuccessful approach to secure design.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SFD2.2</measureId>
									<measureTitle>Create an SSG capability to solve difficult design problems.</measureTitle>
									<detailMessage>The SSG contributes to new architecture and solves difficult design problems, minimizing the negative impact that security has on other constraints (time to market, price, etc.). If a skilled security architect from the SSG is involved in the design of a new protocol, he or she can analyze the security implications of existing protocols and identify elements that should be duplicated or avoided. Likewise, having a security architect understand the security implications of moving a seemingly well-understood application to the cloud saves a lot of headaches later. Designing for security up front is more efficient than analyzing an existing design for security and refactoring when flaws are uncovered, so the SSG should be involved early in the new project process. Note that some design problems will require specific expertise outside of the SSG: even the best expert can’t scale to cover the needs of an entire software portfolio.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SFD3.1</measureId>
									<measureTitle>Form a review board or central committee to approve and maintain secure design patterns.</measureTitle>
									<detailMessage>A review board or central committee formalizes the process of reaching consensus on design needs and security tradeoffs. Unlike the architecture committee, this group focuses on providing security guidance and also periodically reviews already published design standards (especially around authentication, authorization, and cryptography) to ensure that design decisions don’t become stale or out of date. Moreover, a review board can help control the chaos often associated with the adoption of new technologies when development groups might otherwise make decisions on their own without ever engaging the SSG.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SFD3.2</measureId>
									<measureTitle>Require use of approved security features and frameworks.</measureTitle>
									<detailMessage>Implementers take their security features and frameworks from an approved list or repository. There are two benefits to this activity: developers don’t spend time reinventing existing capabilities, and review teams don’t have to contend with finding the same old defects in new projects or when new platforms are adopted. Essentially, the more a project uses proven components, the easier testing, code review, and architecture analysis become (see [AA1.1 Perform security feature review]). Reuse is a major advantage of consistent software architecture and is particularly helpful for agile development and velocity maintenance in CI/CD pipelines. Container-based approaches make it especially easy to package and reuse approved features and frameworks (see [SE3.4 Use application containers]).</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SFD3.3</measureId>
									<measureTitle>Find and publish mature design patterns from the organization.</measureTitle>
									<detailMessage>The SSG fosters centralized design reuse by collecting design patterns (sometimes referred to as security blueprints) from across the organization and publishing them for everyone to use. A section of the SSG website could promote positive elements identified during architecture analysis so that good ideas are spread. This process is formalized: an ad hoc, accidental noticing isn’t sufficient. In some cases, a central architecture or technology team can facilitate and enhance this activity. Common design patterns accelerate development, so it’s important to use secure design patterns not just for applications but for all software (microservices, APIs, frameworks, infrastructure, and automation).</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<BsimmPractice>
					<practiceName>Standards &amp; Requirements</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SR1.1</measureId>
									<measureTitle>Create security standards.</measureTitle>
									<detailMessage>The SSG meets the organization’s demand for security guidance by creating standards that explain the accepted way to adhere to policy and carry out specific security-centric operations. A standard might describe how to perform authentication on an Android device or how to determine the authenticity of a software update, with the SSG providing a reference implementation. Often, software that isn’t an application requires its own standard (e.g., an API or a microservices architecture). Standards can be deployed in a variety of ways to keep them actionable and relevant. They can be automated into development environments (e.g., worked into an IDE or toolchain), or they can be explicitly linked to code examples or even to containers. In any case, to be considered standards, they must be adopted and enforced.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SR1.2</measureId>
									<measureTitle>Create a security portal.</measureTitle>
									<detailMessage>The organization has a well-known central location for information about software security. Typically, this is an internal website maintained by the SSG that people refer to for the latest and greatest on security standards and requirements, as well as for other resources provided by the SSG (e.g., training). An interactive wiki is better than a static portal with guideline documents that rarely change. Organizations can supplement these materials with mailing lists and face-to-face meetings. Development teams are increasingly putting software security knowledge directly into toolchains and automation that is be outside the organization (e.g., GitHub), but that does not remove the need for SSG-led knowledge management.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SR1.3</measureId>
									<measureTitle>Translate compliance constraints to requirements.</measureTitle>
									<detailMessage>Compliance constraints are translated into software requirements for individual projects. This is a linchpin in the organization’s compliance strategy: by representing compliance constraints explicitly with requirements, the organization demonstrates that compliance is a manageable task. For example, if the organization routinely builds software that processes credit card transactions, PCI DSS compliance plays a role in the SSDL during the requirements phase. In other cases, technology standards built for international interoperability can include security guidance on compliance needs. Representing these standards as requirements also helps with traceability and visibility in the event of an audit. It’s particularly useful to codify the requirements into reusable code or container specifications.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SR2.2</measureId>
									<measureTitle>Create a standards review board.</measureTitle>
									<detailMessage>The organization creates a review board to formalize the process used to develop standards and to ensure that all stakeholders have a chance to weigh in. This standards review board could operate by appointing a champion for any proposed standard, putting the onus on the champion to demonstrate that the standard meets its goals and to get approval and buy-in from the review board. Enterprise architecture or enterprise risk groups sometimes take on the responsibility of creating and managing standards review boards. When the standards are implemented directly as software, the responsible champion might be a DevOps manager, release engineer, or whomever owns the associated container or service registry.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SR2.4</measureId>
									<measureTitle>Identify open source.</measureTitle>
									<detailMessage>Open source components included in the software portfolio are identified and reviewed to really understand their dependencies. It’s not uncommon to discover old versions of components with known vulnerabilities or multiple versions of the same component. Automated tools for finding open source, whether whole components or large chunks of borrowed code, are one way to approach this activity. An informal annual review or a process that relies solely on developers asking for permission does not generate satisfactory results.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SR2.5</measureId>
									<measureTitle>Create SLA boilerplate.</measureTitle>
									<detailMessage>The SSG works with the legal department to create standard SLA boilerplate for use in contracts with vendors and outsource providers (including cloud providers) to require software security efforts. The legal department understands that the boilerplate also helps prevent compliance and privacy problems. Under the agreement, vendors and outsource providers must meet company-mandated software security standards (see [CP2.4 Include software security SLAs in all vendor contracts]). Boilerplate language might call for objective third-party insight into software security efforts, such as BSIMMsc measurements or BSIMM scores.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SR3.1</measureId>
									<measureTitle>Control open source risk.</measureTitle>
									<detailMessage>The organization has control over its exposure to the vulnerabilities that come along with using open source components and all the involved dependencies. The use of open source could be restricted to predefined projects or to a short-list of open source versions that have been through an SSG security screening process, have had unacceptable vulnerabilities remediated, and are made available only through specific internal repositories and containers. In some cases, policy might preclude any use of open source. The legal department often spearheads additional open source controls due to the “viral” license problem associated with GPL code. In general, getting the legal department to understand security risks can help move an organization to improve its open source risk management practices, which must be applied across the software portfolio to be effective.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SR3.2</measureId>
									<measureTitle>Communicate standards to vendors.</measureTitle>
									<detailMessage>The SSG works with vendors to educate them and promote the organization’s security standards. However, a healthy relationship with a vendor isn’t guaranteed through contract language alone, so the SSG should engage with vendors, discuss vendor security practices, and explain in concrete terms (rather than legalese) what the organization expects of its vendors. Any time a vendor adopts the organization’s security standards, it’s a clear sign of progress. When the firm’s SSDL is publicly available, communication regarding software security expectations is easier. Likewise, sharing internal practices and measures can make expectations clear.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SR3.3</measureId>
									<measureTitle>Use secure coding standards.</measureTitle>
									<detailMessage>Secure coding standards help the organization’s developers avoid the most obvious bugs and provide ground rules for code review. These standards are necessarily specific to a programming language or platform, and they can address the use of popular frameworks and libraries. Platforms might include mobile or IoT runtimes, cloud service provider APIs, and SaaS platforms (e.g., Salesforce, SAP). If the organization already has coding standards for other purposes, its secure coding standards should build upon them. A clear set of secure coding standards is a good way to guide both manual and automated code review, as well as to provide relevant examples for security training. Some groups might choose to integrate their secure coding standards directly into automation, but violation of the standards must still be considered a defect to be fixed. Remember, if the secure coding standards are not specific and enforced, they won’t be effective.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SR3.4</measureId>
									<measureTitle>Create standards for technology stacks.</measureTitle>
									<detailMessage>The organization standardizes on specific technology stacks. For the SSG, this means a reduced workload because the group doesn’t have to explore new technology risks for every new project. Ideally, the organization will create a secure base configuration for each technology stack, further reducing the amount of work required to use the stack safely. A stack might include an operating system, a database, an application server, and a runtime environment (e.g., a LAMP stack). In other cases, the stack might be an application server and development framework bundle (e.g., MEAN) or even layers 1 through 6 in a cloud environment (e.g., functions-as-a-service). The security frontier is a good place to find traction; mobile technology stacks and platforms, IoT devices, and cloud-based technology stacks are areas where specific attention to security particularly pays off. Container-based approaches can make standardization more scalable (see [SE3.4 Use application containers]).</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<!--Additional BsimmPractice Objects-->
			</practices>
		</BsimmFunction>
		<BsimmFunction>
			<functionName>SSDL Touchpoints</functionName>
			<practices>
				<BsimmPractice>
					<practiceName>Architecture Analysis</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>AA1.1</measureId>
									<measureTitle>Perform security feature review.</measureTitle>
									<detailMessage>To get started in architecture analysis, center the process on a review of security features. Security-aware reviewers identify the security features in an application (authentication, access control, use of cryptography, etc.) and then inspect the design for problems that would cause these features to fail at their purpose or otherwise prove insufficient. For example, this kind of review would identify both a system that was subject to escalation of privilege attacks because of broken access control as well as a mobile application that stashed away PII in local storage. In some cases, use of the firm’s secure-by-design components can streamline this process. Be aware that cloud service provider APIs and the services behind them are often integral to the way certain security features work.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AA1.2</measureId>
									<measureTitle>Perform design review for high-risk applications.</measureTitle>
									<detailMessage>The organization learns the benefits of AA by seeing real results for a few high-risk, high-profile applications. Reviewers must have some experience performing detailed design reviews and breaking the architecture under consideration, especially for new platforms or environments. In all cases, a design review should produce a set of architecture flaws and a plan to mitigate them. If the SSG isn’t yet equipped to perform an in-depth AA, it can use consultants to do this work, but it should participate actively. Ad hoc review paradigms that rely heavily on expertise can be used here, but they don’t tend to scale in the long run. A review focused only on whether a software project has performed the right process steps won’t generate useful results about architecture flaws. Note that a sufficiently robust design review process can’t be executed at CI/CD speed.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AA1.3</measureId>
									<measureTitle>Have SSG lead design review efforts.</measureTitle>
									<detailMessage>The SSG takes a lead role in AA by performing a design review to uncover flaws. Breaking down an architecture is enough of an art that the SSG must be proficient at it before it can turn the job over to architects, and proficiency requires practice. The SSG can’t be successful on its own, either; it will likely need help from architects or implementers to understand the design. With a clear design in hand, the SSG might be able to carry out the detailed review with a minimum of interaction with the project team. Over time, the responsibility for leading review efforts should shift toward software security architects. Approaches to AA, including threat modeling, evolve over time, so it’s wise to not expect to set a process and use it forever.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AA1.4</measureId>
									<measureTitle>Use a risk questionnaire to rank applications.</measureTitle>
									<detailMessage>To facilitate security feature and design review processes, the SSG uses a risk questionnaire or similar method—whether manual or automated—to collect information about each application in order to assign a risk classification and associated prioritization. Information needed for an assignment might include, “Which programming languages is the application written in?” or “Who uses the application?” or “Is the application deployed in a container?” Typically, a qualified member of the application team provides the information, where the process should be short enough to take only a few minutes. Some teams might use automation to gather the necessary data. The SSG can use the answers to categorize the application as high, medium, or low risk. Because a risk questionnaire can be easy to game, it’s important to put into place some spot-checking for validity and accuracy. An overreliance on self-reporting or automation can render this activity useless.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>AA2.1</measureId>
									<measureTitle>Define and use AA process.</measureTitle>
									<detailMessage>The SSG defines and documents a process for AA and applies it in the design reviews it conducts to find flaws. This process includes a standardized approach for thinking about attacks, security properties, and the associated risk, and it is defined well enough that people outside the SSG can learn to carry it out. Pay particular attention to documenting both the architecture under review and any security flaws uncovered, as well as risk information people can understand. Individual ad hoc approaches to AA don’t count as a defined process. Microsoft’s STRIDE and Synopsys’s Architecture Risk Analysis are examples of such a process, although even these two methodologies for AA have evolved greatly over time.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AA2.2</measureId>
									<measureTitle>Standardize architectural descriptions.</measureTitle>
									<detailMessage>Defined AA processes use an agreed-upon format to describe architecture, including a means for representing data flow. Combining a documented process along with standardized architecture descriptions will make AA tractable for people who aren’t security experts. In the case of cloud applications, data are likely to flow across the Internet, so a network diagram is useful in this case, but the description should go into detail about how the software itself is structured. A standard architecture description can be enhanced to provide an explicit picture of information assets that require protection. Standardized icons that are consistently used in diagrams, templates, and whiteboard squiggles are especially useful, too.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>AA3.1</measureId>
									<measureTitle>Have engineering teams lead AA process.</measureTitle>
									<detailMessage>Engineering teams lead the AA process most of the time. This effort requires a well-understood and well-documented process (see [AA2.1 Define and use AA process]), although the SSG still might contribute to AA in an advisory capacity or under special circumstances. Even with a good process, consistency is difficult to attain because breaking architecture requires experience, so provide architects with SSG or outside expertise on novel issues.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AA3.2</measureId>
									<measureTitle>Drive analysis results into standard architecture patterns.</measureTitle>
									<detailMessage>Failures identified during AA are fed back to a security design committee so that similar mistakes can be prevented in the future through improved design patterns (see [SFD3.1 Form a review board or central committee to approve and maintain secure design patterns]). Security design patterns can interact in surprising ways that break security, so the AA process should be applied even when vetted design patterns are in standard use.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>AA3.3</measureId>
									<measureTitle>Make the SSG available as an AA resource or mentor.</measureTitle>
									<detailMessage>To build an AA capability outside of the SSG, the SSG advertises itself as a resource or mentor for teams that ask for help in using the AA process (see [AA2.1 Define and use AA process]) to conduct their own design review. The SSG can answer AA questions during office hours and, in some cases, might assign someone to sit with the architect for the duration of the analysis. In the case of high-risk software, the SSG should play a more active mentorship role in applying the AA process.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<BsimmPractice>
					<practiceName>Code Review</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>CR1.2</measureId>
									<measureTitle>Have the SSG perform ad hoc review.</measureTitle>
									<detailMessage>The SSG performs an ad hoc code review for high-risk applications in an opportunistic fashion, such as by following up a design review with a code review looking for security issues. This informal targeting often evolves into a systematic approach. SSG review could involve the use of specific tools and services, or it might be manual, but it has to be part of a proactive process. When new technologies pop up, new approaches to code review might become necessary.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CR1.4</measureId>
									<measureTitle>Use automated tools along with manual review.</measureTitle>
									<detailMessage>Incorporate static analysis into the code review process to make the review more efficient and consistent. Automation won’t replace human judgment, but it does bring definition to the review process and security expertise to reviewers who typically aren’t security experts. Note that a specific tool might not cover an entire portfolio, especially when new languages are involved, but that’s no excuse not to review the code. A firm might use an external service vendor as part of a formal code review process for software security, but this service should be explicitly connected to a larger SSDL defect management process applied during software development, not just used to “check the security box” on the path to deployment.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CR1.5</measureId>
									<measureTitle>Make code review mandatory for all projects.</measureTitle>
									<detailMessage>Code review is mandatory for all projects under the SSG’s purview, with a lack of code review or unacceptable results stopping a release, slowing it down, or causing it to be recalled. While all projects must undergo code review, the process might be different for different kinds of projects. The review for low-risk projects might rely more heavily on automation, for example, whereas high-risk projects might have no upper bound on the amount of time spent by reviewers. Having a minimum acceptable standard forces projects that don’t pass to be fixed and reevaluated. A code review tool with nearly all the rules turned off (so it can run at CI/CD automation speeds, for example) won’t provide sufficient defect coverage. Similarly, peer code review focused on quality and style won’t provide useful security results.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CR1.4</measureId>
									<measureTitle>Use centralized reporting to close the knowledge loop and drive training.</measureTitle>
									<detailMessage>The bugs found during code review are tracked in a centralized repository that makes it possible to do both summary and trend reporting for the organization. The code review information can be incorporated into a CISO-level dashboard that might include feeds from other parts of the security organization (e.g., penetration tests, security testing, black-box testing, and white-box testing). Given the historical code review data, the SSG can also use the reports to demonstrate progress and drive the training curriculum (see [SM3.3 Identify metrics and use them to drive budgets]). Individual bugs make excellent training examples.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>CR2.5</measureId>
									<measureTitle>Assign tool mentors.</measureTitle>
									<detailMessage>Mentors are available to show developers how to get the most out of code review tools. If the SSG has the most skill with the tools, it could use office hours or other outreach to help developers establish the right configuration or get started on interpreting results. Alternatively, someone from the SSG might work with a development team for the duration of the first review they perform. Centralized use of a tool can be distributed into the development organization or toolchains over time through the use of tool mentors, but providing installation instructions and URLs to centralized tools isn’t the same as mentoring. In many organizations, satellite members take on the tool mentorship role.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CR2.6</measureId>
									<measureTitle>Use automated tools with tailored rules.</measureTitle>
									<detailMessage>Customize static analysis to improve efficiency and reduce false positives. Adding custom rules can help uncover security defects specific to the organization’s coding standards or the framework-based or cloud-provided middleware it uses. The same group that provides tool mentoring will likely spearhead the customization. Tailored rules can be explicitly tied to proper usage of technology stacks in a positive sense and avoidance of errors commonly encountered in a firm’s code base in a negative sense. To reduce the workload for everyone, many organizations also create rules to remove repeated false positives and turn off checks that aren’t relevant.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CR2.7</measureId>
									<measureTitle>Use a top N bugs list (real data preferred).</measureTitle>
									<detailMessage>The SSG maintains a living list of the most important kinds of bugs that it wants to eliminate from the organization’s code and uses it to drive change. Many organizations start with a generic list pulled from public sources but lists such as the OWASP Top 10 rarely reflect an organization’s bug priorities. The list’s value comes from being specific to the organization, built from real data gathered from code review, testing, software composition analysis, and actual incidents, and prioritized for prevention efforts. Simply sorting the day’s bug data by number of occurrences won’t produce a satisfactory list because these data change so often. To increase interest, the SSG can periodically publish a “most wanted” report after updating the list. One potential pitfall with a top N list is that it tends to only include known problems. Of course, just building the list won’t accomplish anything; everyone has to actually use it to kill bugs.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>CR3.2</measureId>
									<measureTitle>Build a capability to combine assessment results.</measureTitle>
									<detailMessage>Combine assessment results so that multiple analysis techniques feed into one reporting and remediation process. Analysis techniques might include static analysis, dynamic analysis, software composition analysis, container scanning, and so on. The SSG might write scripts to gather data automatically and combine the results into a format that can be consumed by a single downstream review and reporting solution. The tricky part of this activity is normalizing vulnerability information from disparate sources that use conflicting terminology. In some cases, using a standardized taxonomy (e.g., a CWE-like approach) can help with normalization. Combining multiple sources helps drive better-informed risk mitigation decisions.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CR3.3</measureId>
									<measureTitle>Eradicate specific bugs from the entire codebase.</measureTitle>
									<detailMessage>When a new kind of bug is found, the SSG writes rules to find it and uses these rules to identify all occurrences of the new bug throughout the entire codebase. It’s possible to eradicate the bug type entirely without waiting for every project to reach the code review portion of its lifecycle. A firm with only a handful of software applications will have an easier time with this activity than firms with a large number of large applications.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CR3.4</measureId>
									<measureTitle>Automate malicious code detection.</measureTitle>
									<detailMessage>Automated code review is used to identify dangerous code written by malicious in-house developers or outsource providers. Examples of malicious code that could be targeted include backdoors, logic bombs, time bombs, nefarious communication channels, obfuscated program logic, and dynamic code injection. Although out-of-the-box automation might identify some generic malicious-looking constructs, custom rules for the static analysis tools used to codify acceptable and unacceptable code patterns in the organization’s codebase will quickly become a necessity. Manual code review for malicious code is a good start but insufficient to complete this activity at scale. While not all backdoors or similar code were meant to be malicious when they were written (e.g., a developer’s feature to bypass authentication during testing), such things have a tendency to stay in deployed code and should be treated as malicious code until proven otherwise.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CR3.5</measureId>
									<measureTitle>Enforce coding standards.</measureTitle>
									<detailMessage>The enforced portions of an organization’s secure coding standards often start out as a simple list of banned functions, with a violation of these standards being sufficient grounds for rejecting a piece of code. Other useful coding standard topics might include proper use of cloud APIs, use of approved cryptography, memory sanitization, and many others. Code review against standards must be objective: it shouldn’t devolve into a debate about whether the noncompliant code is exploitable. In some cases, coding standards for developers are published specific to technology stacks and then enforced during the code review process or directly in the IDE. Standards can be positive (“do it this way”) or negative (“do not use this API”), but they must be enforced to be useful.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<BsimmPractice>
					<practiceName>Security Testing</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>ST1.1</measureId>
									<measureTitle>Ensure QA supports edge/boundary value condition testing.</measureTitle>
									<detailMessage>QA efforts go beyond functional testing to perform basic adversarial tests and probe simple edge cases and boundary conditions, with no particular attacker skills required. When QA understands the value of pushing past standard functional testing that uses expected input, it begins to move slowly toward thinking like an adversary. A discussion of boundary value testing can lead naturally to the notion of an attacker probing the edges on purpose (for example, determining what happens when someone enters the wrong password over and over).</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>ST1.3</measureId>
									<measureTitle>Drive tests with security requirements and security features.</measureTitle>
									<detailMessage>QA targets declarative security mechanisms with tests derived from requirements and security features. A test could try to access administrative functionality as an unprivileged user, for example, or verify that a user account becomes locked after some number of failed authentication attempts. For the most part, security features can be tested in a fashion similar to other software features; security mechanisms based on requirements such as account lockout, transaction limitations, entitlements, and so on are tested with both expected and unexpected input. Software security isn’t security software, but testing security features is an easy way to get started. New software architectures and deployment models, such as with cloud, might require novel test approaches.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>ST2.1</measureId>
									<measureTitle>Integrate black-box security tools into the QA process.</measureTitle>
									<detailMessage>The organization uses one or more black-box security testing tools as part of the QA process. Such tools are valuable because they encapsulate an attacker’s perspective, albeit generically; tools such as IBM Security AppScan or Fortify WebInspect are relevant for web applications, while Prowler is relevant for AWS deployments. In some situations, other groups might collaborate with the SSG to apply the tools. For example, a testing team could run the tool but come to the SSG for help interpreting the results. Because of the way testing is integrated into agile development approaches, black-box tools might be hooked into toolchains or be used directly by engineering. Regardless of who runs the black-box tool, the testing should be properly integrated into the QA cycle of the SSDL.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>ST2.2</measureId>
									<measureTitle>Share security results with QA.</measureTitle>
									<detailMessage>The SSG routinely shares results from security reviews with the QA department. Using security results to inform and evolve particular testing patterns can be a powerful mechanism leading to better security testing. CI/CD makes this easier because of the way testing is integrated in a cross-functional team. Over time, QA engineers learn the security mindset, and this activity benefits from an engineering-focused QA function that is highly technical.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>ST2.4</measureId>
									<measureTitle>Share security results with QA.</measureTitle>
									<detailMessage>The SSG or others with security testing data routinely share results from security reviews with those responsible for testing. Using testing results as the basis for a conversation about common attack patterns or the underlying causes of code vulnerabilities allows QA to generalize that information into new test approaches. CI/CD makes this easier because of the way testing is integrated into the cross-functional team. Over time, QA learns the security mindset, and the organization benefits from an improved ability to create security tests tailored to the organization’s code.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>ST2.5</measureId>
									<measureTitle>Include security tests in QA automation.</measureTitle>
									<detailMessage>Security tests are included in an automation framework and run alongside other QA tests. While many groups trigger these tests manually, in a modern toolchain, these tests are likely part of the pipeline and triggered through automation. Security tests might be derived from abuse cases identified earlier in the lifecycle, from creative tweaks of functional tests, developer tests, security feature tests, or even from guidance provided by penetration testers on how to reproduce an issue.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>ST2.6</measureId>
									<measureTitle>Perform fuzz testing customized to application APIs.</measureTitle>
									<detailMessage>QA efforts include running a customized fuzzing framework against APIs critical to the organization. They could begin from scratch or use an existing fuzzing toolkit, but the necessary customization often goes beyond creating custom protocol descriptions or file format templates to giving the fuzzing framework a built-in understanding of the application interfaces it calls into. Test harnesses developed explicitly for particular applications make good places to integrate fuzz testing.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>ST3.3</measureId>
									<measureTitle>Drive tests with risk analysis results.</measureTitle>
									<detailMessage>Testers use architecture analysis results (see [AA 2.1 Define and use AA process]) to direct their work. If the AA determines that “the security of the system hinges on the transactions being atomic and not being interrupted partway through,” for example, then torn transactions will become a primary target in adversarial testing. Adversarial tests like these can be developed according to risk profile, with high-risk flaws at the top of the list.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>ST3.4</measureId>
									<measureTitle>Leverage coverage analysis.</measureTitle>
									<detailMessage>Testers measure the code coverage of their security tests (see [ST2.5 Include security tests in QA automation]) to identify code that isn’t being exercised. In turn, code coverage analysis drives increased security testing depth. Standard-issue black-box testing tools achieve exceptionally low coverage, leaving a majority of the software under test unexplored, which isn’t a testing best practice. Coverage analysis is easier when using standard measurements such as function coverage, line coverage, or multiple condition coverage.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>ST3.5</measureId>
									<measureTitle>Begin to build and apply adversarial security tests (abuse cases).</measureTitle>
									<detailMessage>Testing begins to incorporate test cases based on abuse cases (see [AM2.1 Build attack patterns and abuse cases tied to potential attackers]) as testers move beyond verifying functionality and take on the attacker’s perspective. One way to do this is to systematically attempt to replicate incidents from the organization’s history. Abuse and misuse cases based on the attacker’s perspective can also be derived from security policies, attack intelligence, standards, and the organization’s top N attacks list (see [AM2.5 Build and maintain a top N possible attacks list]). This effort turns the corner from testing features to attempting to break the software under test.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<!--Additional BsimmPractice Objects-->
			</practices>
		</BsimmFunction>
		<BsimmFunction>
			<functionName>Deployment</functionName>
			<practices>
				<BsimmPractice>
					<practiceName>Penetration Testing</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>PT1.1</measureId>
									<measureTitle>Use external penetration testers to find problems.</measureTitle>
									<detailMessage>Use external penetration testers to demonstrate that the organization’s code needs help. Breaking a high-profile application to provide unmistakable evidence that the organization isn’t somehow immune to the problem often gets the right attention. Over time, the focus of penetration testing moves from trying to determine if the code is broken in some areas to a sanity check done before shipping. External penetration testers that bring a new set of experiences and skills to the problem are the most useful.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>PT1.2</measureId>
									<measureTitle>Feed results to the defect management and mitigation system.</measureTitle>
									<detailMessage>Penetration testing results are fed back to development through established defect management or mitigation channels, with development responding via a defect management and release process. Emailing the results to various people doesn’t generate useful results. Properly done, this exercise demonstrates the organization’s ability to improve the state of security, and many firms are emphasizing the critical importance of not just identifying but actually fixing security problems. One way to ensure attention is to add a security flag to the bug-tracking and defect management system. The organization might leverage developer workflow or social tooling (e.g., Slack, JIRA) to communicate change requests, but those requests are still tracked explicitly as part of a vulnerability management process.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>PT1.3</measureId>
									<measureTitle>Use penetration testing tools internally.</measureTitle>
									<detailMessage>The organization creates an internal penetration testing capability that uses tools. This capability can be part of the SSG or part of a specialized team elsewhere in the organization, with the tools improving the efficiency and repeatability of the testing process. Tools used can include off-the-shelf products built specifically for application penetration testing, network penetration tools that specifically understand the application layer, and custom scripts. Free-time or crisis-driven efforts aren’t the same as an internal capability.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>PT2.2</measureId>
									<measureTitle>Penetration testers use all available information.</measureTitle>
									<detailMessage>Penetration testers, whether internal or external, use source code, design documents, architecture analysis results, misuse and abuse cases, and code review results to do deeper analysis and find more interesting problems. To effectively do their job, penetration testers often need everything created throughout the SSDL, so an SSDL that creates no useful artifacts about the code will make this effort harder. Having access to the artifacts is not the same as using them.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>PT2.3</measureId>
									<measureTitle>Schedule periodic penetration tests for application coverage.</measureTitle>
									<detailMessage>The SSG periodically tests all applications in its purview according to an established schedule, which could be tied to a calendar or a release cycle. High-profile applications should get a penetration test at least once a year. This testing serves as a sanity check and helps ensure that yesterday’s software isn’t vulnerable to today’s attacks; it can also help maintain the security of software configurations and environments, especially containers and components in the cloud. One important aspect of periodic testing is to make sure that the problems identified are actually fixed and don’t creep back into the build. New automation created for CI/CD deserves penetration testing as well.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>PT3.1</measureId>
									<measureTitle>Use external penetration testers to perform deep-dive analysis.</measureTitle>
									<detailMessage>The organization uses external penetration testers to do deep-dive analysis for critical projects and to introduce fresh thinking into the SSG. These testers should be experts and specialists who keep the organization up to speed with the latest version of the attacker’s perspective and have a track record for breaking the type of software being tested. Skilled penetration testers will always break a system, but the question is whether they demonstrate new kinds of thinking about attacks that can be useful when designing, implementing, and hardening new systems. Creating new types of attacks from threat intelligence and abuse cases prevents checklist-driven approaches that only look for known types of problems, which is essential when it comes to new technologies.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>PT3.2</measureId>
									<measureTitle>Have the SSG customize penetration testing tools and scripts.</measureTitle>
									<detailMessage>The SSG either creates penetration testing tools or adapts publicly available ones to more efficiently and comprehensively attack the organization’s software. Tools will improve the efficiency of the penetration testing process without sacrificing the depth of problems that the SSG can identify. Automation can be particularly valuable in organizations using agile methodologies because it helps teams go faster. Tools that can be tailored are always preferable to generic tools. Success here is often dependent upon both the depth of tests and their scope.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<BsimmPractice>
					<practiceName>Software Environment</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SE1.1</measureId>
									<measureTitle>Use application input monitoring.</measureTitle>
									<detailMessage>The organization monitors the input to the software that it runs in order to spot attacks. For web code, a web application firewall (WAF) can do this job, while other kinds of software likely require other approaches. The SSG might be responsible for the care and feeding of the monitoring system, but incident response isn’t part of this activity. For web applications, WAFs that write log files can be useful if someone periodically reviews the logs and takes action. Other software and technology stacks, such as mobile and IoT, likely require their own input monitoring solutions. Serverless and containerized software can require interaction with vendor software to get the appropriate logs and monitoring data. Cloud deployments and platform-as-a-service usage can add another level of difficulty to the monitoring, collection, and aggregation approach.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SE1.2</measureId>
									<measureTitle>Ensure host and network security basics are in place.</measureTitle>
									<detailMessage>The organization provides a solid foundation for its software by ensuring that host and network security basics are in place across its data centers and networks. Evolving network perimeters, increased connectivity and data sharing, and increasing interdependence on vendors (e.g., content delivery, load balancing, and content inspection services) add a degree of difficulty even to getting the basics right. Doing software security before getting host and network security in place is like putting on shoes before putting on socks.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SE2.2</measureId>
									<measureTitle>Publish installation guides.</measureTitle>
									<detailMessage>The SSDL requires the creation of an installation guide or a clearly described configuration (such as for a container) to help deployment teams and operators install and configure software securely. If special steps are required to ensure a deployment is secure, these steps can either be outlined in the guide or explicitly noted in deployment automation; the guide should include a discussion of COTS and vendor components as well. In some cases, installation guides are distributed to customers who buy the software. All deployment automation should be understandable by humans, not just machines. Increasingly, this means infrastructure scripting (e.g., Terraform, Helm, Ansible, and Chef) becomes the installation guide.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SE2.4</measureId>
									<measureTitle>Use code signing.</measureTitle>
									<detailMessage>The organization uses code signing for software published across trust boundaries, which is particularly useful for protecting the integrity of software that leaves the organization’s control, such as shrink-wrapped applications or thick clients. In cloud environments, leveraging code signing might be important when packaging and distributing mobile applications, containers, and machine images through vendor registries or in-house hosted registries. The fact that some mobile platforms require the application code itself to be signed doesn’t indicate institutional use of code signing.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>SE3.2</measureId>
									<measureTitle>Use code protection.</measureTitle>
									<detailMessage>To protect intellectual property and make exploit development harder, the organization erects barriers to reverse engineering its software (e.g., anti-tamper, debug protection, anti-piracy features, runtime integrity). This is particularly important for widely distributed mobile applications. For some software, obfuscation techniques could be applied as part of the production build and release process. In other cases, the protections could be applied at the software-defined network or software orchestration layer when applications are being dynamically regenerated post-deployment. On some platforms, employing Data Execution Prevention (DEP), Safe Structured Error Handling (SafeSEH), and Address Space Layout Randomization (ASLR) can be a good start at making exploit development more difficult.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SE3.3</measureId>
									<measureTitle>Use application behavior monitoring and diagnostics.</measureTitle>
									<detailMessage>The organization monitors production software to look for misbehavior or signs of attack. This activity goes beyond host and network monitoring to look for software-specific problems, such as indications of malicious behavior. Intrusion detection and anomaly detection systems at the application level might focus on an application’s interaction with the operating system (through system calls) or with the kinds of data that an application consumes, originates, and manipulates. In any case, the signs that an application isn’t behaving as expected will be specific to the software and its environment, so one-size-fits-all solutions probably won’t generate satisfactory results. In some types of environments (e.g., PaaS), some of this data and the associated predictive analytics might come from a vendor.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SE3.4</measureId>
									<measureTitle>Use application containers.</measureTitle>
									<detailMessage>The organization uses application containers to support its software security goals, which likely include ease of deployment, a tighter coupling of applications with their dependencies, immutability, integrity (see [SE2.4 Use code signing]), and some isolation benefits without the overhead of deploying a full OS on a virtual machine. Containers provide a convenient place for security controls to be applied and updated consistently. While containers can be useful in development and test environments, production use provides the real benefit.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SE3.5</measureId>
									<measureTitle>Use orchestration for containers and virtualized environments.</measureTitle>
									<detailMessage>The organization uses automation to scale service, container, and virtual machine deployments in a disciplined way. Orchestration processes take advantage of built-in and add-on security controls to ensure each deployed workload meets predetermined security requirements. Setting security behaviors in aggregate allows for rapid change when the need arises. Orchestration platforms are themselves software that become part of your production environment, which in turn requires security patching and configuration; in other words, if you use Kubernetes, make sure you patch Kubernetes.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SE3.6</measureId>
									<measureTitle>Enhance application inventory with operations bill of materials.</measureTitle>
									<detailMessage>A list of applications and their locations in production environments is essential information for any well-run enterprise (see [CMVM2.3 Develop an operations inventory of applications]). In addition, a manifest detailing the components, dependencies, configurations, external services, and so on for all production software helps the organization to tighten its security posture, that is, to react with agility as attackers and attacks evolve, compliance requirements change, and the number of items to patch grows quite large. Knowing where all the components live in running software—whether they’re in private data centers, in clouds, or sold as box products—allows for timely response when unfortunate events occur. Done properly, institutional use of container security solutions can make inventory efforts much simpler.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>SE3.7</measureId>
									<measureTitle>Ensure cloud security basics.</measureTitle>
									<detailMessage>Organizations should already be ensuring that their host and network security basics are in place, but they must also ensure that basic requirements are met in cloud environments. Of course, cloud-based virtual assets often have public-facing services that create an attack surface (e.g., cloud-based storage) that is different from the one in a private data center, so these assets require customized security configuration and administration. In the increasingly software-defined world, the SSG has to help everyone explicitly implement cloud-based security features and controls (some of which can be built in, for example, to cloud provider administration consoles) that are comparable to those built with cables and physical hardware in private data centers. Detailed knowledge about cloud provider shared responsibility security models is always necessary.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<BsimmPractice>
					<practiceName>Configuration &amp; Vulnerability Management</practiceName>
					<levels>
						<BsimmLevel>
							<levelNum>1</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>CMVM1.1</measureId>
									<measureTitle>Create or interface with incident response.</measureTitle>
									<detailMessage>The SSG is prepared to respond to an event or alert, and is regularly included in the incident response process, either by creating its own incident response capability or by regularly interfacing with the organization’s existing team. A regular meeting between the SSG and the incident response team can keep information flowing in both directions. Having pre-built communication channels with critical vendors (e.g., infrastructure, SaaS) is also very important.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CMVM1.2</measureId>
									<measureTitle>Identify software defects found in operations monitoring and feed them back to development.</measureTitle>
									<detailMessage>Defects identified through operations monitoring are fed back to development and used to change developer behavior. In some cases, the contents of production logs can be revealing (or can reveal the need for improved logging). Offering a way to enter incident triage data into an existing bug-tracking system (perhaps by making use of a special security flag) seems to solve some problems, but the idea is to close the information loop and make sure that security issues get fixed. In the best of cases, processes in the SSDL can be improved based on operational data.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>2</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>CMVM2.1</measureId>
									<measureTitle>Have emergency codebase response.</measureTitle>
									<detailMessage>The organization can make quick code changes when an application is under attack, with a rapid-response team working in conjunction with application owners and the SSG to study the code and the attack, find a resolution, and fix the production code (e.g., push a patch into production, rollback to a known-good version, deploy a new container). Often, the emergency response team is the engineering team itself. A well-defined process is a must here, but a process that has never been used might not actually work.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CMVM2.2</measureId>
									<measureTitle>Track software bugs found in operations through the fix process.</measureTitle>
									<detailMessage>Defects found in operations are fed back to development, entered into established defect management systems, and tracked through the fix process. This capability could come in the form of a two-way bridge between bug finders and bug fixers, but make sure the loop is closed completely. Setting a security flag in the bug-tracking system can help facilitate tracking.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CMVM2.3</measureId>
									<measureTitle>Develop an operations inventory of applications.</measureTitle>
									<detailMessage>The organization has a map of its software deployments. If a piece of code needs to be changed, operations or DevOps teams can reliably identify all the places where the change needs to be installed. Common components shared between multiple projects can be noted so that, when an error occurs in one application, other applications that share the same components can be fixed as well.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<BsimmLevel>
							<levelNum>3</levelNum>
							<measures>
								<BsimmMeasure>
									<measureId>CMVM3.1</measureId>
									<measureTitle>Fix all occurrences of software bugs found in operations.</measureTitle>
									<detailMessage>The organization fixes all instances of each bug found during operations, not just the small number of instances that trigger bug reports. This requires the ability to reexamine the entire codebase when new kinds of bugs come to light (see [CR3.3 Eradicate specific bugs from the entire codebase]). One way to approach this is to create a rule set that generalizes a deployed bug into something that can be scanned for via automated code review. Use of containers can greatly simplify deploying the fix for all occurrences of a software bug.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CMVM3.2</measureId>
									<measureTitle>Enhance the SSDL to prevent software bugs found in operations.</measureTitle>
									<detailMessage>Experience from operations leads to changes in the SSDL, which can in turn be strengthened to prevent the reintroduction of bugs found during operations. To make this process systematic, each incident response postmortem could include a “feedback to SSDL” step. This works best when root-cause analysis pinpoints where in the SDLC an error could have been introduced or slipped by uncaught. DevOps engineers might have an easier time with this because all the players are likely involved in the discussion and the solution. An ad hoc approach to SSDL improvement isn’t sufficient.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CMVM3.3</measureId>
									<measureTitle>Simulate software crises.</measureTitle>
									<detailMessage>The SSG simulates high-impact software security crises to ensure software incident response capabilities minimize damage. Simulations could test for the ability to identify and mitigate specific threats or, in other cases, begin with the assumption that a critical system or service is already compromised and evaluate the organization’s ability to respond. When simulations model successful attacks, an important question to consider is the time required to clean up. Regardless, simulations must focus on security-relevant software failure and not on natural disasters or other types of emergency response drills. Organizations that are highly dependent on vendor infrastructure (e.g., cloud service providers, SaaS) and security features will naturally include those things in crisis simulations.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CMVM3.4</measureId>
									<measureTitle>Operate a bug bounty program.</measureTitle>
									<detailMessage>The organization solicits vulnerability reports from external researchers and pays a bounty for each verified and accepted vulnerability received. Payouts typically follow a sliding scale linked to multiple factors, such as vulnerability type (e.g., remote code execution is worth $10,000 versus CSRF is worth $750), exploitability (demonstrable exploits command much higher payouts), or specific service and software versions (widely deployed or critical services warrant higher payouts). Ad hoc or short-duration activities, such as capture-the-flag contests or informal crowd-sourced efforts, don’t constitute a bug bounty program.</detailMessage>
								</BsimmMeasure>
								<BsimmMeasure>
									<measureId>CMVM3.5</measureId>
									<measureTitle>Automate verification of operational infrastructure security.</measureTitle>
									<detailMessage>The SSG works with engineering teams to facilitate a controlled self-service process that replaces some traditional IT efforts, such as application and infrastructure deployment, and includes verification of security properties (e.g., adherence to agreed-upon security hardening). Engineers now create networks, containers, and machine instances, orchestrate deployments, and perform other tasks that were once IT’s sole responsibility. In facilitating this change, the organization uses machine-readable policies and configuration standards to automatically detect and report on infrastructure that does not meet expectations. In some cases, the automation makes changes to running environments to bring them into compliance. In many cases, organizations use a single policy to manage automation in different environments, such as in multi-cloud and hybrid-cloud environments.</detailMessage>
								</BsimmMeasure>
								<!--Additional BsimmMeasure Objects-->
							</measures>
						</BsimmLevel>
						<!--Additional BsimmLevel Objects-->
					</levels>
				</BsimmPractice>
				<!--Additional BsimmPractice Objects-->
			</practices>
		</BsimmFunction>
		<!--Additional BsimmFunction Objects-->
	</functions>
	<comparisons>
		<BsimmComparison>
			<comparisonTitle>Earth Comparison</comparisonTitle>
			<functions>
				<BsimmComparisonFunction>
					<functionName>Governance</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Strategy &amp; Metrics</practiceName><!-- Must match a practice above -->
							<value>2.00</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Compliance &amp; Policy</practiceName><!-- Must match a practice above -->
							<value>2.10</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Training</practiceName><!-- Must match a practice above -->
							<value>1.5</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>Intelligence</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Attack Models</practiceName><!-- Must match a practice above -->
							<value>1.10</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Security Features &amp; Design</practiceName><!-- Must match a practice above -->
							<value>1.60</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Standards &amp; Requirements</practiceName><!-- Must match a practice above -->
							<value>1.80</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>SSDL Touchpoints</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Architecture Analysis</practiceName><!-- Must match a practice above -->
							<value>1.20</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Code Review</practiceName><!-- Must match a practice above -->
							<value>1.50</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Security Testing</practiceName><!-- Must match a practice above -->
							<value>1.40</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>Deployment</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Penetration Testing</practiceName><!-- Must match a practice above -->
							<value>1.50</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Software Environment</practiceName><!-- Must match a practice above -->
							<value>1.70</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Configuration &amp; Vulnerability Management</practiceName><!-- Must match a practice above -->
							<value>2.00</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<!--Additional BsimmComparisonFunction Objects-->
			</functions>
		</BsimmComparison>
		<BsimmComparison>
			<comparisonTitle>Healthcare Comparison</comparisonTitle>
			<functions>
				<BsimmComparisonFunction>
					<functionName>Governance</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Strategy &amp; Metrics</practiceName><!-- Must match a practice above -->
							<value>1.80</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Compliance &amp; Policy</practiceName><!-- Must match a practice above -->
							<value>2.30</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Training</practiceName><!-- Must match a practice above -->
							<value>0.90</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>Intelligence</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Attack Models</practiceName><!-- Must match a practice above -->
							<value>0.90</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Security Features &amp; Design</practiceName><!-- Must match a practice above -->
							<value>1.40</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Standards &amp; Requirements</practiceName><!-- Must match a practice above -->
							<value>1.60</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>SSDL Touchpoints</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Architecture Analysis</practiceName><!-- Must match a practice above -->
							<value>1.20</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Code Review</practiceName><!-- Must match a practice above -->
							<value>1.30</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Security Testing</practiceName><!-- Must match a practice above -->
							<value>1.10</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>Deployment</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Penetration Testing</practiceName><!-- Must match a practice above -->
							<value>1.40</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Software Environment</practiceName><!-- Must match a practice above -->
							<value>1.40</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Configuration &amp; Vulnerability Management</practiceName><!-- Must match a practice above -->
							<value>1.70</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<!--Additional BsimmComparisonFunction Objects-->
			</functions>
		</BsimmComparison>
		<BsimmComparison>
			<comparisonTitle>Cloud Comparison</comparisonTitle>
			<functions>
				<BsimmComparisonFunction>
					<functionName>Governance</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Strategy &amp; Metrics</practiceName><!-- Must match a practice above -->
							<value>2.20</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Compliance &amp; Policy</practiceName><!-- Must match a practice above -->
							<value>2.20</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Training</practiceName><!-- Must match a practice above -->
							<value>1.90</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>Intelligence</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Attack Models</practiceName><!-- Must match a practice above -->
							<value>1.10</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Security Features &amp; Design</practiceName><!-- Must match a practice above -->
							<value>1.80</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Standards &amp; Requirements</practiceName><!-- Must match a practice above -->
							<value>2.10</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>SSDL Touchpoints</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Architecture Analysis</practiceName><!-- Must match a practice above -->
							<value>1.10</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Code Review</practiceName><!-- Must match a practice above -->
							<value>1.50</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Security Testing</practiceName><!-- Must match a practice above -->
							<value>1.30</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>Deployment</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Penetration Testing</practiceName><!-- Must match a practice above -->
							<value>1.60</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Software Environment</practiceName><!-- Must match a practice above -->
							<value>2.00</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Configuration &amp; Vulnerability Management</practiceName><!-- Must match a practice above -->
							<value>2.30</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<!--Additional BsimmComparisonFunction Objects-->
			</functions>
		</BsimmComparison>
		<BsimmComparison>
			<comparisonTitle>Tech Comparison</comparisonTitle>
			<functions>
				<BsimmComparisonFunction>
					<functionName>Governance</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Strategy &amp; Metrics</practiceName><!-- Must match a practice above -->
							<value>2.10</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Compliance &amp; Policy</practiceName><!-- Must match a practice above -->
							<value>1.90</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Training</practiceName><!-- Must match a practice above -->
							<value>1.50</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>Intelligence</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Attack Models</practiceName><!-- Must match a practice above -->
							<value>1.50</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Security Features &amp; Design</practiceName><!-- Must match a practice above -->
							<value>1.50</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Standards &amp; Requirements</practiceName><!-- Must match a practice above -->
							<value>1.70</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>SSDL Touchpoints</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Architecture Analysis</practiceName><!-- Must match a practice above -->
							<value>1.40</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Code Review</practiceName><!-- Must match a practice above -->
							<value>1.30</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Security Testing</practiceName><!-- Must match a practice above -->
							<value>1.80</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<BsimmComparisonFunction>
					<functionName>Deployment</functionName> <!-- Must match a function above -->
					<practices>
						<BsimmComparisonPractice>
							<practiceName>Penetration Testing</practiceName><!-- Must match a practice above -->
							<value>1.70</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Software Environment</practiceName><!-- Must match a practice above -->
							<value>2.30</value>
						</BsimmComparisonPractice>
						<BsimmComparisonPractice>
							<practiceName>Configuration &amp; Vulnerability Management</practiceName><!-- Must match a practice above -->
							<value>2.40</value>
						</BsimmComparisonPractice>
						<!--Additional BsimmComparisonPractice Objects-->
					</practices>
				</BsimmComparisonFunction>
				<!--Additional BsimmComparisonFunction Objects-->
			</functions>
		</BsimmComparison>
		<!--Additional BsimmComparison Objects-->
	</comparisons>
</BsimmSurvey>